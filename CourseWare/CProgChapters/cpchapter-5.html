<!DOCTYPE HTML>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <title>程序设计基础</title>
    <meta name="description" content="第5章函数">
    <meta name="author" content="Liyi">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobil-web-app-status-bar-style" content="black">

    <link rel="stylesheet" href="../../dist/reset.css">
    <link rel="stylesheet" href="../../dist/reveal.css">
    <link rel="stylesheet" href="../../dist/theme/white.css" id="theme">

    <!-- Theme used for syntax highlighting of code -->
    <link rel="stylesheet" href="../../plugin/highlight/monokai.css" id="highligh">

    <style type="text/css">
        .columnleft {
            float: left;
            width: 50%;
        }

        .columnright {
            float: right;
            width: 50%;
        }

        .columncenter {
            float: center;
            width: 33%;
        }

        li {
            text-align: left;
            font-size: 80%;
        }

        p {
            text-align: left;
        }

        .smallft {
            text-align: left;
            font-size: 80%;
        }

        .smcft {
            font-size: 80%;
        }
    </style>
</head>

<body>
    <div class="reveal">
        <div class="slides">
            <section id="titlepage">
                <h1>程序设计基础</h1>
                <H2>第五章 函数</H2>
                
                <p id="date" style="text-align:center"></p>
                <script>
                    var now = new Date();
                    var year = now.getFullYear();
                    var month = now.getMonth();
                    var day = now.getDate();
                    document.getElementById("date").innerHTML = year + "年" + (1 + month) + "月" + day + "日";
                </script>
            </section>
            <section id="toc">
                <h2>第5章 函数</h2>
                <p>
                    <a href="#/5-1">5.1 计算圆柱体积</a><br />
                    <a href="#/5-2">5.2 数字金字塔</a><br />
                    <a href="#/5-3">5.3 复数运算</a><br />
                </p>
            </section>
            <section id="chpkeys">
                <h2>本章要点</h2>
                <ul>
                    <li>函数的作用是什么? 如何确定函数功能?</li>
                    <li>怎样定义函数? 如何调用函数? 定义函数与声明函数有何区别?</li>
                    <li>什么是函数的参数? 怎样确定函数的参数?</li>
                    <li>在函数调用时，参数是如何传递数据的?</li>
                    <li>变量与函数有什么关系? 如何使用局部变量和全局变量?</li>
                    <li>什么是静态变量?</li>
                </ul>
            </section>
            <section>
                <section id="5-1">
                    <h2>5.1 计算圆柱体积</h2>
                    <p style="text-align:center; font-size: 100%; font-weight:bold">例5-1. 输入圆柱体的高和半径，求圆柱体的体积$volume=\pi\times r^2\times h$，要求定义和调用函数cylinder(r, h)计算圆柱体积</p>
                </section>
                <section id="5-1-1">
                    <h3>5.1.1 程序解析</h3>
                    <pre>
                        <code class="hljs" data-trim data-line-numbers>
#include&lt;stdio.h&gt;
double cylinder(double r, double h); /* 函数声明 */
int main()
{
    double height, radius, volumne;
    printf("Enter radius and height: ");
    scanf("%lf%lf", &radius, &height);
    volume=cylinder(radius, height);  /* 函数调用，将函数的返回值赋给volume */
    printf("Volume=%.3f\n", volume);
    return 0;
}
double cylinder(double r, double h)   /* 定义函数求圆柱体的体积 */
{
    double result;
    result=3.1415926*r*r*h;           /* 计算体积 */
    return result;                    /* 返回结果 */
}
                        </code>
                    </pre>
                    <p class="smallft fragment">
                        函数调用是如何运行的?
                    </p>
                </section>
                <section id="5-1-2">
                    <h3>5.1.2 函数的定义</h3>
                    <ul>
                        <li class="smallft">函数是指完成一个特定工作的独立程序模块</li>
                        <ul>
                            <li class="smallft">库函数，由C语言系统提供定义，如scanf, printf等函数</li>
                            <li class="smallft">自定义函数，需要用户自已定义，如计算圆柱体何种函数cylinder()</li>
                        </ul>
                        <li class="smallft">main()也是一个函数，C程序由一个main()或多个函数构成</li>
                        <li class="smallft">程序中一旦调用了某个函数，该函数就会完成特定的计算，然后<text style="color:red">返回到调用它的地方</text></li>
                        <ul>
                            <li class="smallft">函数经过运算，会得到一个明确的运算结果，并需要回送该结果，如函数cylinder()返回圆柱的体积</li>
                        </ul>
                    </ul>
                </section>
                <section id="5-1-2-1">
                    <h3>函数定义(2)</h3>
                    <p style="text-align:left; font-size:60%">
                        函数定义形式:<br />
                        /* 函数首部 函数类型为返回值的类型，与return语句中表达式的类型一致 */<br />
                        <text style="color:red; font-weight:bold">函数类型 函数名(函数参数列表表)</text> <br />
                        <text style="color:red; font-weight:bold">{</text> /* 函数体 */<br />
                        &nbsp;&nbsp;&nbsp;&nbsp;<text style="color:red; font-weight:bold">函数实现体</text><br />
                        &nbsp;&nbsp;&nbsp;&nbsp;<text style="color:red; font-weight:bold">return 表达式;</text> /* 将函数运算的结果送回调用该函数的地方 */<br />
                        <text style="color:red; font-weight:bold">}</text>
                    </p>
                    <pre>
                        <code class="hljs" data-trim>
/* 函数类型 double, 函数名 cylinder, 参数列表 double r和double h */
double cylinder(double r, double h) /* 函数首部 */
{   /* 函数体，写在一对大括号内 */
    double result;                 /* 函数内的局部变量 */
    result=3.1415926*r*r*h;        /* 计算圆柱体积 */
    return result;                 /* 返回运算结果，类型与函数类型一致 */
}
                        </code>
                    </pre>
                </section>
                <section id="5-1-2-2">
                    <h3>函数参数(形参)</h3>
                    <pre>
                        <code class="hljs" data-trim>
double cylinder(double r, double h)
{
    double result;
    result=3.1415926*r*r*h;
    return result;
}
                        </code>
                    </pre>
                    <p class="smallft">
                        函数的参数列表必须写成:<text style="color:red">类型1 参数1, 类型2 参数2, ......, 类型n 参数n</text><br />
                        参数之间用<text style="color:red">逗号</text>分隔，每个参数前面的类型都必须分别写明。比如上述函数中，参数double r, double h不能写成double r, h<br />
                    </p>
                </section>
                <section id="5-1-3">
                    <h3>5.1.3 函数的调用</h3>
                    <ul>
                        <li class="smallft">定义一个函数后，就可以通过程序来调用这个函数</li>
                        <li class="smallft">调用标准库函数时，在程序的最前面用<text style="color:red">#include</text>命令包含相应的头文件</li>
                        <li class="smallft">调用自定义函数时，程序中必须有与调用函数相对应的<text style="color:red">函数定义</text></li>
                    </ul>
                </section>
                <section id="5-1-3-1">
                    <h3>函数调用的形式</h3>
                    <ul>
                        <li class="smallft">函数调用的一般形式为: <text style="color:darkred">函数名(实际参数列表)</text></li>
                        <li class="smallft">对于实现计算功能的函数，函数调用通常会出现在两种情况中</li>
                        <ul>
                            <li class="smallft">赋值语句，如volume=cylinder(radius, height);</li>
                            <li class="smallft">输出函数的结果，printf("%f", cylinder(radius, height));</li>
                        </ul>
                    </ul>
                </section>
                <section id="5-1-3-2">
                    <h3>函数调用的过程</h3>
                    <p class="smallft">
                        程序执行<text style="color:darkred">从主函数main开始</text><br />
                        如果遇到函数调用，<text style="color:darkred">暂停执行主函数</text>，转到执行相应的函数<br />
                        函数执行完毕后，<text style="color:darkred">返回主函数</text>，再从原来主函数暂停的位置继续执行<br />
                        如果调用函数执行过程中遇到return，则直接返回主函数
                    </p>
                </section>
                <section id="5-1-3-3">
                    <h3>分析函数调用的过程</h3>
                    <p class="smallft">
                        见DevC++
                    </p>
                    <pre>
                        <code class="hljs" data-trim data-line-numbers>
#include&lt;stdio.h&gt;
double cylinder(double r, double h); /* 函数声明 */
int main()
{
    double height, radius, volumne;
    printf("Enter radius and height: ");
    scanf("%lf%lf", &radius, &height);
    volume=cylinder(radius, height);  /* 函数调用 8-->12  */
    printf("Volume=%.3f\n", volume);
    return 0;
}
double cylinder(double r, double h)   /* 参数列表赋值，实参->形参 */
{
    double result;                    /* 执行函数中的语句 */
    result=3.1415926*r*r*h;
    return result;                    /* 返回结果到调用的地方，第8行 */
}
                        </code>
                </section>
                <section id="5-1-3-4">
                    <h3>参数传递</h3>
                    <ul>
                        <li class="smallft">函数<text style="color:darkred">定义</text>时的参数被称为<text style="color:darkred">形式参数</text>，简称(<text style="color:darkred">形参</text>)<br />
                        double cylinder(double r, double h)</li>
                        <li class="smallft">函数<text style="color:darkred">调用</text>时的参数被称为<text style="color:darkred">实际参数</text>，简称(<text style="color:darkred">实参</text>)<br />
                        volume=cylinder(radius, height);</li>
                        <li class="smallft">参数传递，从<text style="color:darkred">实参</text>--><text style="color:darkred">形参</text>，是<text style="color:darkred">单向传递</text></li>
                        <ul>
                            <li class="smallft">在参数传递过程中，实参将值<text style="color:darkred">复制</text>给形参</li>
                            <li class="smallft">形参和实参<text style="color:darkred">一一对应</text>：数量一致，类型一致，顺序一致</li>
                            <li class="smallft"><text style="color:darkred">形参</text>: 是变量，用于接受实参传递过来的值</li>
                            <li class="smallft"><text style="color:darkred">实参</text>: 可以是常量、变量或表达式</li>
                        </ul>
                    </ul>
                </section>
                <section id="5-1-3-5">
                    <h3>函数结果返回</h3>
                    <p class="smallft">
                        调用函数完成计算后，将运算结果返回给<text style="color:darkred">调用的函数</text>，函数结果的返回形式一般有:<br />
                        &nbsp;&nbsp;&nbsp;&nbsp;return 表达式;
                    </p>
                    <p class="smallft">
                        return可用于返回函数运算的结果，也可用于终止调用函数的运行。函数只能返回一个值，如需要返回多个值，需采用其它方法实现
                    </p>
                </section>
                <section id="5-1-3-6">
                    <h3>函数原型声明</h3>
                    <p style="color:darkblue; text-align:left; font-weight:bold; font-size:80%">
                        函数声明，只写函数的首部，以分号结束，不包含函数体，即函数的实现部分<br />
                        <text style="color:darkred">函数类型 函数名(参数列表)<text style="color:red">;</text></text><br />
                        double volume(double r, double h);<br />
                        void pyramid(int n);
                    </p>
                    <ul>
                        <li class="smallft">函数必须<text style="color:darkred">先定义后调用</text>，将主调函数放在被调函数的后面，就像变量先定义后使用一样</li>
                        <li class="smallft">如果自定义函数在主调函数的后面，就需要在函数调用前，加上函数原型声明</li>
                        <li class="smallft">函数声明，用于说明函数的类型和参数列表，以保证程序编译时能判断对该函数的调用是否正确</li>
                    </ul>
                </section>
                <section id="5-1-4">
                    <h3>5.1.4 函数程序设计</h3>
                    <p style="text-align:center; font-size: 100%; font-weight:bold">例5-2. 计算五边形的面积</p>
                    <p>将一个五边形分割成3个三角形，输入这些三角形的7条边长，计算该五边形的面积。要求定义和调用函数area(x,y,z)计算边长为x,y,z的三角形面积
                    </p>
                    <img src="../images/cprog/chap05/5-1.png" style="width:40%"/>
                </section>
                <section id="5-1-4-1">
                    <h3>计算五边形面积源程序</h3>
                    <pre>
                        <code class="hljs" data-trim data-line-numbers>
#include&lt;stdio.h&gt;
#include&lt;math.h&gt;
double area(double x, double y, double z);
int main()
{
    double a1, a2, a3, a4, a5, a6, a7, s;
    printf("Please input 7 side lengths in the order a1 to a7:");
    scanf("%lf%lf%lf%lf%lf%lf%lf", &a1, &a2, &a3, &a4, &a5, &a6, &a7);
    s=area(a1, a5, a6)+area(a4, a6, a7)+area(a2, a3, a7); /* 调用三次area函数计算面积 */
    printf("The area of the pentagon is %.2f\n", s);
    return 0;
}
/* 使用海伦-秦九韶公式计算三角形面积的函数 */
double area(double x, double y, double z)
{
    double p=(x+y+z)/2;
    return sqrt(p*(p-x)*(p-y)*(p-z));
}
                        </code>
                    </pre>
                </section>
                <section id="5-1-4-2">
                    <h3>自定义函数程序的优点</h3>
                    <ul>
                        <li class="smallft">程序结构清晰，逻辑关系明确，程序可读性强</li>
                        <li class="smallft">解决相同或相似问题时不用重复编写代码、可通过调用函数解决，减少代码量</li>
                        <li class="smallft">利用函数实现模块化编程，各模块功能相对独立，利用“各个击破”降低调试难度</li>
                    </ul>
                </section>
                <section id="5-1-4-3">
                    <h3>练习</h3>
                    <p style="text-align:center; font-size: 80%; font-weight:bold">练习. 判断奇偶数</p>
                    <p style="text-align:left; font-size: 80%;">定义一个判断奇偶数的函数even(n)，当n为偶数时返回1，否则返回0。利用该函数计算1-500之间所有偶数的和</p>
                    <pre class="fragment" style="font-size:35%">
                        <code class="hljs" data-trim data-line-numbers="3-9|12-22">
#include&lt;stdio.h&gt;
/* 判断奇偶性的函数 */
int even(int n)
{
    if(n%2==0)
        return 1;
    else
        return 0;
}

/* 求1-500之间所有偶数的和 */
int main()
{
    int i, sum=0;
    for(i=1; i<=500; i++)
    {
        if(even(i)==1)
            sum=sum+i;
    }
    printf("%d", sum);
    return 0;
}
                        </code>
                    </pre>
                </section>
                <section id="5-1-4-4">
                    <h3>判断完全平方数</h3>
                    <p style="text-align:center; font-size: 100%; font-weight:bold">例5-3. 判断完全平方数</p>
                    <p style="text-align:left; font-size:80%">定义一个判断完全平方数的函数isSquare(n)，当n为完全平方数时返回1，否则返回0，不允许使用数学库函数<br />
                        如果n是完全平方数，则可以找到正整数m使$n=m^2$成立。在<text style="color:darkred">不使用函数sqrt()</text>的情况下，我们可以判断一个数是否为完全平方数。例如，当n为完全平方数时，n可采用以下等差数列求和公式计算:
                        $$
                        1+3+5+7+\cdots+(2\times m-1)=m^2=n
                        $$
                    </p>
                </section>
                <section id="5-1-4-5">
                    <h3>判断完全平方数程序实现</h3>
                    <pre style="font-size:45%">
                        <code class="hljs" data-trim data-line-numbers>
#include&lt;stdio.h&gt;
int isSquare(int n)
{
    int i;
    for(i=1; n>0; i=i+2)
    {
        n=n-i;
    }
    if(n==0)
        return 1; /* 是完全平方数返回1 */
    else
        return 0; /* 不是完全平方数返回0 */
}

int main()
{
    int n;
    printf("Enter n:");
    scanf("%d", &n);
    if(isSquare(n)==1)
        printf("%d is complete square number.\n", n);
    else
        printf("%d is not a complete square number.\n", n);
}
                        </code>
                    </pre>
                </section>
                <section id="5-1-4-6">
                    <h3>求最大公约数</h3>
                    <p style="text-align:center; font-size: 100%; font-weight:bold">例5-4. 求最大公约数</p>
                    <p style="text-align:left; font-size:80%">定义函数gcd(int m, int n)，计算m和n的最大公约数
                    </p>
                    <div class="columnleft">
                        <p class="smallft">
                            辗转相除法(欧几里得算法)<br />
                            1. temp=m%n<br />
                            2. 若temp为0，返回n的值，否则转3.<br />
                            3. m=n, n=temp, 转1继续
                        </p>
                    </div>
                    <div class="columnright">
                        <img src="../images/cprog/chap05/5-2.png" style="width:50%" />
                    </div>
                </section>
                <section id="5-1-4-7">
                    <h3>求最大公约数源程序</h3>
                    <pre style="font-size:40%">
                        <code class="hljs" data-trim data-line-numbers>
#include&lt;stdio.h&gt;
int gcd(int m, int n)
{
    int r, temp;
    if(m&lt;n)  /* 保证m比n大 */
    {
        temp=m;
        m=n;
        n=temp;
    }
    r=m%n;
    while(r!=0){
        m=n;
        n=r;
        r=m%n;
    }
    return n;
}
int main()
{
    int m, n;
    int g;
    printf("Enter two numbers m, n(m&gt;n):");
    scanf("%d%d", &m, &n);
    g=gcd(m, n);
    printf("GCD of %d and %d is %d", m, n, g);
    return 0;
}
                        </code>
                    </pre>
                </section>
                <section id="5-1-4-8">
                    <h3>使用函数判断素数</h3>
                    <p style="text-align:center; font-size: 100%; font-weight:bold">例5-5. 使用函数判断素数</p>
                    <p style="text-align:left; font-size:80%">求100以内的全部素数，每行输出10个。素数是只能被1和自身整除的正整数，1不是素数，2是素数。<br />
                        要求定义和调用函数prime(m)判断m是否为素数，当m为素数时返回1，否则返回0
                    </p>
                </section>
                <section id="5-1-4-9">
                    <h3>使用函数判断素数源程序</h3>
                    <pre style="font-size:35%">
                        <code class="hljs" data-trim data-line-numbers>
#include&lt;stdio.h&gt;
#include&lt;math.h&gt;
int prime(int m)
{
    int i, n, limit;
    if(m<=1)
        return 0;
    else if(m==2)
        return 1;
    else{
        limit=sqrt(m)+1;
        for(i=2; i<=limit; i++){
            if(m%i==0)
                return 0;
        }
    }
    return 1;
}
int main()
{
    int count, m;
    count=0;
    for(m=2; m<=100; m++){
        if(prime(m)!=0){
            printf("%6d", m);
            count++;
            if(count%10==0)
                printf("\n");
        }
    }
    printf("\n");
    return 0;
}
                        </code>
                    </pre>
                </section>
                <section id="5-1-4-10">
                    <h3>求$\pi$的近似值</h3>
                    <p style="text-align:center; font-size: 100%; font-weight:bold">示例. 使用函数求$\pi$的近似值</p>
                    <p style="text-align:left; font-size:80%">输入精度e，使用格雷戈里公式求$\pi$的近似值，精确到最后一项的绝对值小于e<br />
                        $$
                        \frac{\pi}{4}=\frac{!}-\frac{1}{3}+\frac{1}{5}-\frac{1}{7}+\cdots
                        $$
                    </p>

                </section>
                <section id="5-1-4-11">
                    <h3>求$\pi$的近似值源程序</h3>
                    <pre style="font-size:40%">
                        <code class="hljs" data-trim data-linenumbers>
#include&lt;stdio.h&gt;
#include&lt;math.h&gt;
double funpi(double e)
{
    int denominator, flag;
    double item, sum;
    flag=1;
    denominator=1;
    item=1.0;
    sum=0;
    while(fabs(item)>=e){
        sum=sum+item;
        flag=-flag;
        denominator=denominator+2;
        item=flag*1.0/denominator;
    }
    sum=sum+item;
    return sum*4;
}
int main()
{
    double e, pi;
    printf("Enter e:");
    scanf("%lf", &e);
    pi=funpi(e);
    printf("pi=%f\n", pi);
    return 0;
}
                        </code>
                    </pre>
                </section>
            </section>
            <section>
                <section id="5-2">
                    <h2>5.2 数字金字塔</h2>
                    <p style="text-align:center; font-size: 100%; font-weight:bold">例5-6. 数字金字塔</p>
                    <p style="text-align:left; font-size:80%">输入一个正整数，输出n行数字金字塔。如当n=5时，输出的金字塔如下图所示
                    </p>
                    <div class="columnleft">
                        <img src="../images/cprog/chap05/5-3.png" />
                    </div>
                    <div class="columnright">
                        <ul>
                            <li class="smallft">一行中的空格处理</li>
                            <li class="smallft">一行中的数字显示</li>
                            <li class="smallft">每一行的数字、空格处理</li>
                        </ul>
                    </div>

                </section>
                <section id="5-2-1">
                    <h3>5.2.1 程序解析</h3>
                    <pre style="font-size:50%">
                        <code class="hljs" data-trim data-line-numbers>
#include&lt;stdio.h&gt;
void pyramid(int n)   /* 函数定义 */
{
    int i, j;
    for(i=1; i<=n; i++){        /* 需要输出的行数 */
        for(j=1; j<=n-i; j++){  /* 输出每行左边的空格 */
            printf(" ");
        }
        for(j=1; j<=i; j++){     /* 输出每行的数字 */
            printf("%d ", i);    /* 注意每个数字后有空格 */
        }
        putchar('\n');           /* 换行 */
    }
}
int main()
{
    int n;
    printf("Enter n:");
    scanf("%d", &n);
    pyramid(n);
    return 0;
}
                        </code>
                    </pre>
                </section>
                <section id="5-2-2">
                    <h3>5.2.2 不返回运算结果的函数</h3>
                    <p style="text-align:left; font-size:60%">
                        <text style="color:red; font-weight:bold">void </text>函数名(参数列表)<br />
                        {<br />
                        &nbsp;&nbsp;&nbsp;&nbsp;函数实现体<br />
                        &nbsp;&nbsp;&nbsp;&nbsp;return;<br />
                        }
                    </p>
                    <p class="smallft">
                        函数定义中，<text style="color:darkred">void</text>表示函数不返回结果，但不能省略，否则函数类型会默认定义为int<br />
                        返回类型为void的函数一般用于输出
                    </p>
                </section>
                <section id="5-2-2-1">
                    <h3>不返回运算结果的函数定义</h3>
                    <ul>
                        <li class="smallft">由于函数没有返回结果，函数调用不可能出现在表达式中，通常以独立的调用语句方式出现，如pyramid(5)</li>
                        <li class="smallft">不返回结果的函数，在定义、调用、参数传递、函数声明上，思路与其它函数定义完全相同，只是函数类型为void</li>
                        <li class="smallft">适用于将一些确定的、相对独立的程序功能包装成函数</li>
                        <ul>
                            <li clas="smallft">主函数通过调用不同的函数，体现算法步骤</li>
                            <li class="smallft">各步骤的实现由相应函数完成</li>
                            <li class="smallft">简化主函数结构，以体现结构化程序设计思想</li>
                        </ul>
                    </ul>
                </section>
                <section id="5-2-3">
                    <h3>结构化程序设计思想</h3>
                    <ul>
                        <li class="smallft">结构化程序设计(Structured Programming)是一种程序设计技术，C语言是结构化程序设计语言</li>
                        <li class="smallft">结构化程序设计强调程序设计的风格和程序结构的规范化，提供清晰的结构</li>
                        <ul>
                            <li class="smallft">其基本思路是将一个复杂问题的求解过程划分为若干阶段，每个阶段要处理的问题都容易被理解和处理</li>
                            <li class="smallft">按照<text style="color:darkred">自顶向下的方法</text>对问题进行分析、模块化设计和结构化编码等3个步骤</li>
                        </ul>
                    </ul>
                </section>
                <section id="5-2-3-1">
                    <h3>自顶向下的分析方法</h3>
                    <ul>
                        <li class="smallft">将大的复杂的<text style="color:darkred">问题分解</text>为小问题后再解决</li>
                        <ul>
                            <li class="smallft">面对一个复杂的问题，首先进行上层(整体)的分析，按组织或功能将问题分解成<text style="color:darkred">子问题</text></li>
                            <li class="smallft">如果子问题仍然十分复杂，再做进一步的分解，直到处理对象<text style="color:darkred">相对简单</text>，容易处理为止</li>
                            <li class="smallft">当所有的子问题都得到了解决，整个问题也就解决了</li>
                        </ul>
                        <li class="smallft">每一次分解都是对上一层问题进行细化和逐步求精，最终形成一种类似<text style="color:darkred">树形的层次结构</text>，来描述分析的结果</li>
                    </ul>
                </section>
                <section id="5-2-3-2">
                    <h3>学生成绩统计程序的层次结构图</h3>
                    <p class="smallft">
                        学生成绩统计程序经分解后得到树状结构，每个模块均设计为独立的函数，整个程序通过调用函数实现
                    </p>
                    <img src="../images/cprog/chap05/5-4.png" />
                </section>
                <section id="5-2-3-3">
                    <h3>模块化设计</h3>
                    <ul>
                        <li class="smallft">模块化设计是将模块组织成良好的层次系统</li>
                        <ul>
                            <li class="smallft">顶层模块调用其下层模块实现程序的完整功能</li>
                            <li class="smallft">每个下层模块再调用更下层的模块，从而完成程序的每一个子功能</li>
                            <li class="smallft">最下层的模块完成最具体的功能</li>
                        </ul>
                        <li class="smallft">遵循模块独立性的原则，即模块之间的联系应尽量简单，尽量保持模块之间的独立性</li>
                        <li class="smallft">模块用函数实现</li>
                        <li class="smallft">一个模块只完成一个指定的功能</li>
                        <li class="smallft">模块之间只能通过带参数的函数进行调用</li>
                    </ul>
                </section>
                <section id="5-2-3-4">
                    <h3>结构化编码的主要原则</h3>
                    <ul>
                        <li class="smallft">经过模块化设计后，每一个模块都可以独立编码，编程时应选用顺序、选择和循环三种控制结构</li>
                        <li class="smallft">对变量、函数、常量等命名时，要见名知意，有助于对变量含义或函数功能的理解</li>
                        <li class="smallft">在程序中增加必要的注释，增加程序的可读性</li>
                        <li class="smallft">要有良好的程序视觉组织，利用缩进格式控制页面排版</li>
                        <li class="smallft">程序要清晰易懂，语句构造要简单直接</li>
                        <li class="smallft">程序有良好的交互性，输入有提示，输出有说明</li>
                    </ul>
                </section>
            </section>
            <section>
                <section id="5-3">
                    <h2>5.3 复数运算</h2>
                    <p style="text-align:center; font-size: 100%; font-weight:bold">例5-7. 计算两个复数的和与积</p>
                    <p style="text-align:left; font-size:80%">分别输入两个复数的实部与虚部，用函数实现计算两个复数的和与积</p>
                    <p class="smallft">
                        若两个复数分别为: c1=x1+y1<text style="color:red;font-style:italic">i</text>, c2=x2+y2<text style="color:red;font-style:italic">i</text><br />
                        则有<br />
                        c1+c2=(x1+x2)+(y1+y2)<text style="color:red;font-style:italic">i</text><br />
                        c1*c2=(x1*x2-y1*y2)+(x1*y2+x2*y1)<text style="color:red;font-style:italic">i</text>
                    </p>
                </section>
                <section id="5-3-1">
                    <h3>5.3.1 程序解析</h3>
                    <pre style="font-size:45%">
                        <code class="hljs" data-trim data-line-numbers>
#include&lt;stdio.h&gt;
double result_real, result_imag; /* 全局变量，用于存放函数结果 */
void complext_add(double real1, double imag1, double real2, double imag2)
{
    result_real=real1+real2;
    result_imag=imag1+imag2;
}
void complex_prod(double real1, double imag1, double real2, double imag2)
{
    result_real=real2*imag1-real1*imag2;
    result_imag=real1*imag2+real2*imag1;
}
int main()
{
    double real1, real2, imag1, imag2; /* 两个复数的实部和虚部 */
    printf("Enter 1st complex number(real and imaginary):");
    scanf("%lf%lf", &real1, &imag1);
    printf("Enter 2nd complex number(real and imaginary):");
    scanf("%lf%lf", &real2, &imag2);   /* 分别输入两个复数的实部和虚部 */
    complex_add(real1, imag1, real2, imag2); /* 计算两个复数的和 */
    printf("addition of complex is %f+%fi\n", result_real, result_imag);
    complex_prod(real1, imag1, real2, imag2); /* 计算两个复数的积 */
    printf("product of complex is %f+%fi\n", result_real, result_imag);
    return 0;
}
                        </code>
                    </pre>
                </section>
                <section id="5-3-2">
                    <h3>5.3.2 全局变量和局部变量</h3>
                    <ul>
                        <li class="smallft">局部变量</li>
                        <ul>
                            <li class="smallft">在函数内定义的变量(包括形式参数)，作用范围在<text style="color:darkred">本函数内部</text></li>
                            <li class="smallft">定义在复合语句内的变量，作用范围在<text style="color:darkred">复合语句内部</text></li>
                        </ul>
                        <li class="smallft">全局变量</li>
                        <ul>
                            <li class="smallft">在函数以外定义的变量，不从属于任何一个函数，其作用范围是<text style="color:darkred">从定义处到源文件结束(包括各函数)</text></li>
                        </ul>
                    </ul>
                </section>
                <section id="5-3-2-1">
                    <h3>在复合语句中定义局部变量</h3>
                    <pre style="font-size:60%">
                        <code class="hljs" data-trim data-line-numbers>
#include&lt;stdio.h&gt;
int main()
{
    int a;
    a=1;
    {              /* 复合语句开始 */
        int b=2;
        b=a+b;
        a=a+b;
    }              /* 复合语句结束 */
    printf("%d", a);
    return 0;
}
                        </code>
                    </pre>
                    <p class="smallft">
                        上述代码的输出是什么？如果将11行改为<text style="color:red">printf("%d", b);</text>结果又如何？
                    </p>
                </section>
                <section id="5-3-2-2">
                    <h3>全局变量定义</h3>
                    <pre style="font-size:40%">
                        <code class="hljs" data-trim data-line-numbers>
#include&lt;stdio.h&gt;
int x;        /* 定义全局变量x */
int f()
{
    int x=4;  /* x是局部变量 */
    return x;
}
int main()
{
    int a=1;
    x=a;      /* 对全局变量x赋值 */
    a=f();    /* a的值为4 */
    {
        int b=2;
        b=a+b;    /* b的值为6 */
        x=x+b;    /* 全局变量运算, x的值为7 */
    }
    printf("%d %d", a, x);
    return 0;
}
                        </code>
                    </pre>
                    <p class="smallft">
                        若局部变量与全局变量同名，局部变量优先
                    </p>
                </section>
                <section id="5-3-2-3">
                    <h3>变量作用范围示例</h3>
                    <pre style="font-size:50%">
                            <code class="hljs" data-trim data-line-numbers>
int x=1;
void main()
{
    int a=2;
    //......
    {
        int b=3;    /* x=? a=? b=? */
        //......
    }
    f();
    //......        /* b=? */
}
int t=4;
void f()
{
    int x=5, b=6;   /* x=? a=? b=? t=? */
    //......
}
int a=7;      /* a=? b=? t=? x=? */
                            </code>
                        </pre>
                </section>
                <section id="5-3-2-4">
                    <h3>用函数实现财务现金记账</h3>
                    <p style="text-align:center; font-size: 100%; font-weight:bold">例5-8. 用函数实现财务现金记账</p>
                    <p style="text-align:left; font-size:80%">先输入操作类型: 1. 收入，2. 支出，0. 结束。再输入操作金额，计算现金剩余额，经多次操作直到输入操作类型为0时结束。要求定义并调用函数，其中现金收与现金支出分别用不同函数实现
                    </p>
                    <p class="smallft">
                        分析：设变量cash保存现金余额值，由于它被主函数、现金收入与现金支出函数共用，任意使用场合其意义与数值都是明确且唯一的，因此将其设为全局变量
                    </p>
                </section>
                <section id="5-3-2-5">
                    <h3>现金记账源程序</h3>
                    <pre style="font-size:35%">
                        <code class="hljs" data-trim data-line-numbers>
#include&lt;stdio.h&gt;
double cash;   /* 定义全局变量，保存现金余额 */
void income(double number)  /* 定义现金收入函数 */
{
    cash=cash+number;       /* 改变全局变量cash的值 */
}
void expend(double number)  /* 定义现金支出函数 */
{
    cash=cash-number;       /* 改变全局变量cash的值 */
}
int main()
{
    int choice;
    double value;
    cash=0;      /* 初始金额为0 */
    printf("Enter operation choice(0-end, 1-income, 2-expend):");
    scanf("%d", &choice);
    while(choice!=0){  /* 若输入类型为0，结束循环 */

        if(choice==1 || choice==2){
            printf(“Enter cash value:");  /* 输入操作现金额 */
            scanf("%f", &value);
            if(choice==1)
                income(value);  /* 函数调用，计算现金收入 */
            else
                expend(value);  /* 函数调用，计算现金支出 */
            printf("Current cash: %.2f\n", cash);
        }
        printf("Enter operation choice(0-end, 1-income, 2-expend):");
        scanf("%d", &choice);
    }
    return 0;
}
                        </code>
                    </pre>
                </section>
                <section id="5-3-2-6">
                    <h3>关于全局变量和局部变量的思考</h3>
                    <ul>
                        <li class="smallft">全局变量比局部变量自由度大，使用更方便?</li>
                        <ul>
                            <li class="smallft">对于规模较大的程序，过多使用全局变量会带来副作用，导致各函数间出现相互干扰。如果整个程序是由多个合作开发，各人都按自己的想法使用全局变量，相互的干扰可能会更严重</li>
                            <li class="smallft">在变量使用中，应尽量使用局部变量，从某个角度看使用似乎受到了限制，但从另一个角度看，它避免了不同函数间的相互干扰，提高了程序质量</li>
                        </ul>
                    </ul>
                </section>
                <section id="5-3-3">
                    <h3>5.3.3 变量生命周期和静态局部变量</h3>
                    <dl>
                        <dt style="font-size:80%">
                            变量生命周期
                        </dt>
                        <dd style="font-size:80%">
                            变量从定义开始分配存储单元，到运行结束存储单元被回收的整个过程
                        </dd>
                        <dt style="font-size:80%">
                            自动变量(<text style="color:red">auto</text>)
                        </dt>
                        <dl style="font-size:80%" 普通的局部变量，比如<br />
                        int x, y; &lt;--&gt; <text style="color:red">auto</text> int x, y;<br />
                        char c1; &lt;--&gt; <text style="color:red">auto</text> char c1;<br />
                        函数调用时，定义变量，分配存储单元；当函数调用结束时，收回存储单元
                    </dl>
                    <dt style="font-size:80%">
                        全局变量
                    </dt>
                    <dd style="font-size:80%">
                        从程序执行开始，到程序的结束，存储单元始终保持的变量
                    </dd>
                    </dl>
                </section>
                <section id="5-3-3-1">
                    <h3>C程序存储分布示意图</h3>
                    <img src="../images/cprog/chap05/5-5.png" style="width:80%" />
                </section>
                <section id="5-3-3-2">
                    <h3>静态局部变量</h3>
                    <p class="smallft">
                        <text style="color:red; font-weight:bold">static</text> 类型名 变量表
                    </p>
                    <p class="smallft">
                        静态局部变量的作用范围是局部，但其生命周期是存在于全局
                    </p>
                </section>
                <section id="5-3-3-3">
                    <h3>计算阶乘</h3>
                    <p style="text-align:center; font-size: 100%; font-weight:bold">例5-9. 计算阶乘</p>
                    <p style="text-align:left; font-size:80%">输入正整数n，输出1!~n!的值。要求定义并调用含静态变量的函数fact_s(n)计算n!
                    </p>
                    <pre style="font-size:40%">
                        <code class="hljs" data-trim data-line-numbers>
#include&lt;stdio.h&gt;
double fact_s(int n)
{
    static double f=1;
    f=f*n;
    return f;
}
int main()
{
    int i, n;
    printf("Enter n:");
    scanf("%d", &n);
    for(i=1; i<=n; i++)
        printf("%3d!=%.0f\n", i, fact_s(i));
    return 0;
}
                        </code>
                    </pre>
                </section>
                <section id="5-3-3-4">
                    <h3>静态局部变量</h3>
                    <ul>
                        <li class="smallft">自动变量如果没有赋初值，其存储单元中将是随机值</li>
                        <li class="smallft">静态变量，如果定义时没有赋初值，系统将自动赋值为0</li>
                        <li class="smallft">赋初值只在函数第一次调用时起作用，以后调用都按前一次调用后保留的值使用</li>
                        <li class="smallft">静态局部变量受变量的作用范围限制，不能作用于其它函数，包括主函数</li>
                    </ul>
                </section>
                <section id="5-3-3-5">
                    <h3>静态变量与全局变量</h3>
                    <ul>
                        <li class="smallft">静态变量与全局变量均位于静态存储区，其共同点是生命周期贯穿整个程序执行过程</li>
                        <li class="smallft">区别在于，作用范围不同，全局变量可作用于所有函数，静态变量只能用于所定义函数，而不能使用于其它函数</li>
                    </ul>
                </section>
            </section>
        </div>
    </div>

    <script src="../../dist/reveal.js"></script>
    <script src="../../plugin/zoom/zoom.js"></script>
    <script src="../../plugin/notes/notes.js"></script>
    <script src="../../plugin/search/search.js"></script>
    <script src="../../plugin/markdown/markdown.js"></script>
    <script src="../../plugin/math/math.js"></script>
    <script src="../../plugin/highlight/highlight.js"></script>
    <script>
        Reveal.initialize({
            // display controls in the bottom right corner
            controls: true,

            // display a presentation progress bar
            progress: true,

            // set default timing of 2 minutes per slides
            defaultTiming: 120,

            // Display the page number of the current slides
            slideNumber: true,

            // Push each slide change to the browser history
            history: false,

            // Enable keyboard shortcuts for navigation
            keyboard: true,

            // Enable the slide overview mode
            overview: true,

            // Vertical centering of slides
            center: true,

            // Enable touch navigation on devices with touch input
            touch: true,

            // Loop the presentation
            loop: false,

            // Change teh presentation direction to be RTL
            rtl: false,

            // Randomizes the order of slides each time the presentation loads
            shuffle: false,

            // Turns fragments on and off globally
            fragment: true,

            // Flags if the presentation is running in an embedded mode,
            // i.e. contained within a limited portion of the screen
            embedded: false,

            // Flags if we should show a help overlay when the questionmark key is pressed
            help: true,

            // Flags if speaker notes should be visible to all viewers
            showNotes: false,

            // Global override for autoplaying embedded media( video/audio/iframe)
            // - null: media will only autoplay if data-autopay is present
            // - true: all media will autoplay, regradless of individual setting
            // - false: no media will autoplay, regardless of individual setting
            autoPlayMedia: null,

            // Number of milliseconds between automatically proceeding to the next slide,
            //disabled when set to 0, this value can be overwritten by
            // using a data-autoslide attribute on your slides
            autoSlide: 0,

            // Stop auto-sliding after user input
            autoSlideStoppable: true,

            // Use this method for navigation when auto-sliding
            autoSlideMethod: Reveal.navigateNext,

            // Enable slide navigation via mouse wheel
            mouseWheel: false,

            // Hides the address bar on mobile devices
            hideAddressBar: true,

            // Opens links in an iframe preview overlay
            previewLinks: false,

            // Transition style
            transition: 'slide', // none/fade/slide/convex/concave/zoom

            // Transition speed
            transitionSpeed: 'default', // default/fast/slow

            // Transition style for full page slide backgrounds
            backgroundTransition: 'fade', // none/fade/slide/convex/concave/zoom

            // Number of slides away from the current that are visible
            viewDistance: 3,

            // Parallax background image
            parallaxBackgroundImage: '', // e.g. "'https://s3.amazonaws.com/hakin-static/reveal-js/reveal-parallax-1.jpg'"

            // Parallax background size
            parallaxBackgroundSize: '', // CSS syntax, e.g. "2100px 900px"

            // Number of pixels to move the parallax background per slide
            // - calculated automatically unless specified
            // - set to 0 to disable movement along an axis
            parallaxBackgroundHorizontal: null,
            parallaxBackgroundVertical: null,

            // The display mode that will be used to show slides
            display: 'block',

            // print to pdf while no slide grows to more than one printed page
            pdfMaxPagesPerSlide: 1,

            // presentation
            //width: 1200,
            //height: 1200,

            //margin: 0.1,

            //minScale: 0.2,
            //maxScale: 1.5,

            math: {
                mathjax: 'https://cdn.jsdelivr.net/gh/mathjax/mathjax@2.7.8/MathJax.js',
                config: 'TeX-AMS_HTML-full',
                // pass other options into `MathJax.Hub.Config()`
                TeX: {
                    Macros: {
                        RR: "{\\bf R}"
                    }
                }
            },

            plugins: [RevealZoom, RevealNotes, RevealSearch, RevealMarkdown, RevealHighlight, RevealMath]
        })
    </script>
</body>

</html>